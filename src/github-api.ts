import * as github from '@actions/github';
import * as core from '@actions/core';

import type { PRResult } from './types.js';
import { GitHubAPIError } from './errors.js';

/**
 * Options for PR creation.
 */
export interface PROptions {
  /** Whether the package has a vendorHash field (buildGoModule) */
  hasVendorHash?: boolean;
  /** Whether rev uses ${version} interpolation */
  revUsesVersion?: boolean;
}

/**
 * Generates the PR body content.
 *
 * @param packageName - Name of the package
 * @param version - New version
 * @param options - PR options
 * @returns The formatted PR body
 */
function generatePRBody(packageName: string, version: string, options: PROptions = {}): string {
  const changes = ['- Updated `version` field'];

  if (options.revUsesVersion !== true) {
    changes.push('- Updated `rev` field');
  }

  changes.push('- Updated source `hash`');

  let body = `## Summary

- Updates \`${packageName}\` to version \`${version}\`
- Auto-generated by nixpkgs-updater action

## Changes

${changes.join('\n')}
`;

  if (options.hasVendorHash === true) {
    body += `
## ⚠️ Action Required: vendorHash

This package uses \`buildGoModule\` with a \`vendorHash\`. The \`vendorHash\` was **not** updated automatically because it cannot be pre-calculated.

**If Go dependencies have changed**, you need to update it manually:

1. Set \`vendorHash = "";\` or \`vendorHash = lib.fakeHash;\`
2. Run \`nix build .#${packageName}\`
3. Copy the correct hash from the error message
4. Update \`vendorHash\` with the correct value

If dependencies haven't changed, the existing \`vendorHash\` should still work.
`;
  }

  return body;
}

/**
 * Creates a new pull request or updates an existing one.
 *
 * @param targetRepo - Target repository in owner/repo format
 * @param token - GitHub token for authentication
 * @param branchName - Branch name for the PR
 * @param packageName - Name of the package being updated
 * @param version - New version of the package
 * @param options - Optional PR settings
 * @returns Result containing PR URL, number, and whether it was created
 * @throws GitHubAPIError if PR creation/update fails
 *
 * @example
 * const result = await createOrUpdatePR(
 *   'shini4i/nixpkgs',
 *   'ghp_token',
 *   'chore/my-package-v1.0.0',
 *   'my-package',
 *   '1.0.0'
 * );
 */
export async function createOrUpdatePR(
  targetRepo: string,
  token: string,
  branchName: string,
  packageName: string,
  version: string,
  options: PROptions = {}
): Promise<PRResult> {
  const octokit = github.getOctokit(token);
  const [owner, repo] = targetRepo.split('/');

  if (owner === undefined || repo === undefined) {
    throw new GitHubAPIError(`Invalid target repository format: ${targetRepo}`);
  }

  const title = `bump ${packageName} version to ${version}`;
  const body = generatePRBody(packageName, version, options);

  try {
    // Check for existing PR from this branch
    const { data: existingPRs } = await octokit.rest.pulls.list({
      owner,
      repo,
      head: `${owner}:${branchName}`,
      state: 'open',
    });

    if (existingPRs.length > 0) {
      // Update existing PR
      const existingPR = existingPRs[0];

      if (existingPR === undefined) {
        throw new GitHubAPIError('Unexpected: existing PR list is empty after length check');
      }

      core.info(`Found existing PR #${String(existingPR.number)}, updating...`);

      await octokit.rest.pulls.update({
        owner,
        repo,
        pull_number: existingPR.number,
        title,
        body,
      });

      return {
        url: existingPR.html_url,
        number: existingPR.number,
        created: false,
      };
    }

    // Create new PR
    const { data: newPR } = await octokit.rest.pulls.create({
      owner,
      repo,
      title,
      body,
      head: branchName,
      base: 'main',
    });

    return {
      url: newPR.html_url,
      number: newPR.number,
      created: true,
    };
  } catch (error) {
    if (error instanceof GitHubAPIError) {
      throw error;
    }
    throw new GitHubAPIError(
      `Failed to create/update PR: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
